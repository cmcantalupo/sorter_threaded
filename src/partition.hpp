// Partition is a class used to break up a vector into pieces that are
// between pivot values.  This is done using std::map and each piece
// is stored in a std::stack.
//
// C.M. Cantalupo 2011
// cmcantalupo@gmail.com

#ifndef st_partition_hpp
#define st_partition_hpp

#include <set>
#include <vector>
#include <map>
#include "partition_wall.hpp"

namespace SorterThreadedHelper {
  // Each thread will have a partition and the members will
  // be single threaded functions.  

  template <class type>
  class Partition {
    public:
      // A partition is created with a set of pivots.  There are
      // pivots.size() + 1 tasks. Each task is a stack of values less
      // than the pivot for the first tasks, and the last task is a
      // stack of values larger than any of the pivots.
      Partition(const std::set<type>& pivots);
      Partition(const Partition& other);
      ~Partition();

      // Pushes all of the values in a chunk onto the partition
      // stacks.
      void fill(typename std::vector<type>::const_iterator begin,
                typename std::vector<type>::const_iterator end);

      // Returns all of the values in the current task.  
      void popTask(typename std::vector<type>::iterator begin);

      // Returns the number of tasks (the size of the original pivot
      // set plus one).
      size_t numTasks();

      // Returns the index of the next task that will be popped by 
      // popTask().  
      size_t curTask();

      // Returns the size of the next task that will be popped by 
      // popTask().
      size_t curSize();

      // Returns the sizes of all of the tasks.  
      void taskSizes(std::vector<size_t> &sizes);

    private:
      size_t numTasks_;
      size_t curTask_;
      typename std::map<PartitionWall<type>, std::stack<type>*> partition_;
      typename std::map<PartitionWall<type>, std::stack<type>*>::iterator curTaskIt_;
  };


  template <class type> 
  Partition<type>::Partition(const std::set<type>& pivots) :
    numTasks_(pivots.size()+1),
    curTask_(0) {
    // A partition is generated by a set of pivots

    // We will create a map between PartitionWalls and their associated stack.  
    typename std::pair<PartitionWall<type>,std::stack<type>*> pp;
    for (typename std::set<type>::iterator it = pivots.begin(); 
         it != pivots.end(); ++it) {
      
      pp.first.set(*it,false);
      pp.second = new std::stack<type>;
      partition_.insert(pp);
    }

    // We need an extra PartitionWall for values that are greater than all the pivots.
    pp.first.set(*pivots.begin(), true);
    pp.second = new std::stack<type>;
    partition_.insert(pp);
    
    // curTaskIt_ keeps track of the next task to be popped by popTask()
    curTaskIt_ = partition_.begin();
  }

  template <class type>
  Partition<type>::~Partition() {
    // Delete all the stacks
    for (typename std::map<PartitionWall<type>,std::stack<type>*>::iterator it = partition_.begin(); 
         it != partition_.end(); ++it) {
      delete it->second;
    }
  }

  template <class type>
  Partition<type>::Partition(const Partition& other) : 
    numTasks_(other.numTasks_), 
    curTask_(other.curTask_) {
    // Basic copy constructor.  
    std::pair<PartitionWall<type>,std::stack<type>*> pp;

    size_t i = 0;
    for (typename std::map<PartitionWall<type>,std::stack<type>*>::const_iterator it = other.partition_.begin(); 
         it != other.partition_.end(); ++it) {
      pp.first = it->first;
      pp.second = new std::stack<type>(*it->second);
      partition_.insert(pp);
      if( i == curTask_ ) {
        curTaskIt_ = partition_.find(it->first);
      }
      ++i;
    }
  }     

  template <class type>
  void Partition<type>::fill(typename std::vector<type>::const_iterator chunkBegin,
                             typename std::vector<type>::const_iterator chunkEnd) {
    // Fills the stacks of the partition from the chunk
    typename std::map<PartitionWall<type>,std::stack<type>*>::iterator ub;
    PartitionWall<type> test;
    for (typename std::vector<type>::const_iterator it = chunkBegin;
         it != chunkEnd; ++it) {
      test.set(*it,false);
      ub = partition_.upper_bound(test);
      // If we go off the end use the extra stack added to end.  
      if (ub == partition_.end()) --ub;
      ub->second->push(*it);
    }
  }

  template <class type>
  void Partition<type>::popTask(typename std::vector<type>::iterator begin) {
    // Fills the input vector with all of the values stored 
    // in the stack pointed to by curTaskIt_;
    typename std::vector<type>::iterator it(begin);
    while (!curTaskIt_->second->empty()) {
      *it = curTaskIt_->second->top();
      curTaskIt_->second->pop();
      ++it;
    }
    // Increment the task iterator.  
    ++curTaskIt_;
    ++curTask_;
    if (curTaskIt_ == partition_.end()) {
      curTaskIt_ = partition_.begin();
      curTask_ = 0;
    }
  }

  template <class type>
  size_t Partition<type>::numTasks() {
    return numTasks_;
  }
  
  template <class type>
  size_t Partition<type>::curTask() {
    return curTask_;
  }

  template <class type>
  size_t Partition<type>::curSize() {
    return curTaskIt_->second->size();
  }

  template <class type>
  void Partition<type>::taskSizes(std::vector<size_t>& sizes) {
    // Fills a vector with the sizes of all the task stacks.
    sizes.resize(numTasks_);
    std::vector<size_t>::iterator sizeIt = sizes.begin();  
    for (typename std::map<PartitionWall<type>,std::stack<type>*>::iterator taskIt = partition_.begin();
         taskIt != partition_.end(); ++taskIt, ++sizeIt) {
      *sizeIt = taskIt->second->size();
    }
  }
}

#endif
  
